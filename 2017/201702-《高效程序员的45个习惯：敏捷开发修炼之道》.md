# 《高效程序员的45个习惯：敏捷开发修炼之道》 #
在武侠天地中，身手敏捷，武功高强，比比皆是，东邪西毒、南帝北丐，个顶个的厉害，跟美国漫威英雄们一样，讲得更多的是超级个体。而今放眼世界，互联网江湖风起云涌，团队作战与社群连结成为主流，在真、美、正义和学问的道路上百花齐放，各显神通。

《高效程序员的45个习惯：敏捷开发修炼之道》这本书就是程序世界中的“武林高手“Andy写给码农们的上层内功心法。

作者结合自身实践体会以及最新认知科学、计算科学的研究成果，深入浅出地讲解敏捷开发过程中重要习惯。

## 一、习惯归类 ##

1. 态度决定一切：（习惯1-4），共计4项习惯；
2. 学无止境：（习惯5-9），共计5项习惯；
3. 交付用户想要的软件：（习惯10-18），共计9项习惯；
4. 敏捷反馈：（习惯19-24），共计6项习惯；
5. 敏捷编码：（习惯25-32），共计8项习惯；
6. 敏捷调试：（习惯33-37），共计5项习惯；
7. 敏捷协作：（习惯38-45），共计8项习惯；

## 二、敏捷开发的45个习惯 ##
### 2.1 ###
- 习惯01：做事
- 习惯02：欲速则不达
- 习惯03：对事不对人
- 习惯04：排除万难，奋勇前进
### 2.2 ###
- 习惯05：跟踪变化
- 习惯06：对团队投资
- 习惯07：懂得丢弃
- 习惯08：打破砂锅问到底
- 习惯09：把握开发节奏
### 2.3 ###
- 习惯10：让客户做决定
- 习惯11：让设计指导而不是操纵开发
- 习惯12：合理地使用技术
- 习惯13：保持可以发布
- 习惯14：提早集成，频繁集成
- 习惯15：提早实现自动化部署
- 习惯16：使用演示获得频繁反馈
- 习惯17：使用短迭代，增量发布
- 习惯18：固定的价格就意味着背叛承诺
### 2.4 ###
- 习惯19：守护天使
- 习惯20：先用它再实现它
- 习惯21：不同环境，就有不同问题
- 习惯22：自动验收测试
- 习惯23：度量真实的进度
- 习惯24：倾听用户的声音
### 2.5 ###
- 习惯25：代码要清晰地表达意图
- 习惯26：用代码沟通
- 习惯27：动态评估取舍
- 习惯28：增量式编程
- 习惯29：保持简单
- 习惯30：编写内聚的代码
- 习惯31：告知，不要询问
- 习惯32：根据契约进行替换
### 2.6 ###
- 习惯33：记录问题解决日志
- 习惯34：警告就是错误
- 习惯35：对问题各个击破
- 习惯36：报告所有的异常
- 习惯37：提供有用的错误信息
### 2.7 ###
- 习惯38：定期安排会面时间
- 习惯39：架构师必须写代码
- 习惯40：实行代码集体所有制
- 习惯41：成为指导者
- 习惯42：允许大家自己想办法
- 习惯43：准备好后再共享代码
- 习惯44：做代码复查
- 习惯45：及时通报进展与问题

## 三、习惯落地的技巧与建议 ##
### 3.1 ###
> 习惯1：做事——指责不会修复bug

把矛头对准问题的解决方法，而不是人。这是真正有用处的正面效应。

**建议：**

- 确实有些人常常不把解决问题放在最高优先级上。
- 先自我反省一下：当有问题出现时，你的“第一”反应究竟是什么。
- 问问“为了解决或缓解这个问题，我能够做些什么？”“好，我能帮你做些什么？”
- 停止给问题火上浇油。（抱怨、伤害、推诿。。。）
- 不要与爱搬弄是非的人共事。
- 如果你没有犯过任何错误，就说明你可能没有努力去工作。
- 如果团队中有一个成员产生了误解，也许意味着其他成员也有相同的误解，要确保团队尽快消除误解。

> 习惯2：欲速则不达——不要坠入快速的简单修复之中

要投入时间和精力保持代码的整洁、敞亮。

**建议：**

- 修改代码之前一定要很好地理解它。
- 了解团队的开发方法或者开发过程，即必须要理解团队采用的开发方法。必须理解如何恰如其分地使用这种方法，为何它们是这样的，以及如何成为这样的。
- 花些时间阅读其他同事的代码，确保代码是可读和可理解的。阅读代码的频率越高越好。实现代码复审，及时发现BUG。
- 使用单元测试，即把代码分层，分成很多可管理的小块。
- 从更高的层面来了解大部分代码的功能，充分理解系统各个功能块之间是如何交互的。

> 习惯3：对事不对人

让我们骄傲的应该是解决了问题，而不是比较出谁的主意更好。

对一个明显的错误有哪些常见的反应：
1. 否定个人能力
2. 指出明显的缺点，并否定其观点
3. 询问你的队友，并提出你的顾虑

**建议：**

- Les Brown ：你不需要很出色才能起步，但是你必须起步才能变得很出色。
- 作为一个有远见的人，你一定要特别尊重别人的意见。
- 亚里士多德：能容纳自己并不接受的想法，表明你的头脑足够有学识。
- 设定最终期限。
- 逆向思维
- 设立仲裁人
- 支持已经做出的决定
- 设计充满了妥协（生活本身也是如此），成功属于意识到这一点的团队。

> 习惯4：排除万难，奋勇前进——做正确的事

要诚实，要有勇气去说出实情。有时，这样做很困难，所以我们要有足够的勇气。

**建议：**

- 动手证明好过只是嚷嚷。
- 有时，绝妙的计划会因为勇气不足而最终失败。
- 当发现问题时，不要试图掩盖这些问题。要有勇气站起来，说“我现在知道了，我过去使用的方法不对。我想到一些方法，可以解决这个问题，但可能会花多些时间。如果你有更好的想法，我很乐意听一听。”
### 3.2 ###
> 习惯5：跟踪变化

你不需要精通所有技术，但需要清楚知道行业的动向，从而规划你的项目和职业生涯。

**建议：**

- 迭代和增量式学习
- 了解最新行情
- 参加本地的用户组活动
- 参加研讨会议
- 如饥似渴地阅读
- 正确把握自己投入的精力
- 在某些方面成为专家
- 学习新技术前需要回答：为什么需要学习这项新技术——它试图解决什么样的问题？它可以被用在什么地方？
- 避免一时冲动，在做决策之前，必须评估新技术的优势。先开发一个小的原型系统看看。

> 习惯6：对团队投资——提供你和团队学习的更好平台

通过午餐会议可以增进每个人的知识和技能，并帮助大家聚集在一起进行沟通交流。唤起人们对技术和技巧的热情，将会项目大有裨益。

**建议：**

- 选取每周固定一天，召集大家开展“午餐会议”。
- “午餐会议”的相关要点如下：
 - 什么主题都可以
 - 要求团队中一个人主持会议
 - 由他给大家介绍一些概念，演示工具，或者团队感兴趣的任何一件事情。
 - 主持讲座的人，先讲15分钟，然后，进行开放式讨论，这样每个人都可以发表自己的意见。
 - 讨论这个主题对于项目的意义。
 - 讨论应该包括所能带来的益处。

> 习惯7：懂得丢弃——学习新的东西，丢弃旧的东西

在学习一门新技术的时候，要丢弃会阻止你前进的旧习惯。

**建议：**

1. 拥抱变化，你不可能一直使用相同的技能和工具。
2. 丢弃的第一步，就是要意识到你还在使用过时的方法。
3. 这里所谓的丢弃，其实是提醒我们一定要保证不是习惯性地落入旧习惯。
4. 应该力求尽可能完全转入新的开发环境。

> 习惯8：打破砂锅问到底——不停地问为什么。

不能只满足于别人告诉你的表面现象，要不停地提问直到你明白问题的根源。

**建议**

- 为了解决问题，你需要很好地了解系统的全局
- 查看所有你认为和问题相关的部分——即便其他人觉得这并不相干。
- “为什么”是一个非常好的问题。《第5项修炼》作者建议就某个难题，渐次问5个以上的“为什么”。

> 习惯9：把握开发节奏——解决任务，在事情变得一团糟之前。

保持事件之间稳定重复的间隔，更容易解决常见的重复任务。

**建议**

- 随机安排是很难处理的
- 有人说，上帝发明了时间，就是为了防止所有事情同时发生。
- 我们需要更具远见，保持一定节奏
- 请将此习惯应用于——习惯17：迭代时间、习惯38：站立会议等
- 运用有规律的开发节奏，会更容易达到目标，并确保项目不停地前进。
### 3.3 ###
> 习惯10：让客户做决定

开发者、经理或业务分析师不应该做业务方面的决定。用业务负责人能够理解的语言，向他们详细解释遇到的问题，并让他们做决定。

**建议**

- 开发者（及项目经理）能做的一个最重要的决定就是，判断哪些是自己决定不了的，应该让企业主做决定。
- 如果遇到一个问题，会影响到系统的行为或者如何使用系统，把这个问题告诉业务负责人。
- 当你和客户讨论问题的时候，准备好几种可选择的方案。让客户了解一切（成本、利益、时间、预算、可见影响等）之后再做决定。
- 记录客户做出的决定，并注明原因。好记性不如烂笔头。

> 习惯11：让设计指导而非操作开发——好设计是一张地图，它也会进化

设计指引你向正确的方向前进，它不是殖民地，它不应该标识具体的路线。你不要被设计（或者设计师）操纵。

**建议**

- 设计是帮助你理解系统的细节，理解部件和子系统之间的关系，并且指导你的实现。
- 开始编码之前提出的设计只是基于目前对需求的理解而已。一旦开始了编码，一切都会改变。设计及其代码实现会不停地发展和变化。
- 设计满足实现即可，不必过于详细。任何设计仅是一个起跑点。
- 若采用理想化的瀑布式开发方法，将导致在前面进行了过度的设计。
- 设计可以分为两层：战略和战术。
 - 战略设计阶段：前期的设计属于战略，通常只有在没有深入理解需求的时候需要这样的设计。更确切地说，前期的设计应该只描述总体战略，不应深入到具体细节。良好的战略设计应该扮演地图的角色，指引你向正确的方向前进。这个阶段更适合讨论如何设计类的职责，因为战略设计是一个高层次、面向目标的设计。
 - 战术设计阶段：具体说明程序方法、参数、字段和对象交互精确顺序的细节，应该在项目开发的时候再具体展开。
 - CRC（类-职责-协作）卡片的设计方法就是用来进行战略设计的。
     - 类名。
     - 职责：它应该做什么？
     - 协作者：要完成工作它需要与其他什么对象一起工作。

> 习惯12:合理地使用技术——根据需要选择技术

首先决定什么是你需要的，接着为这些具体的问题评估使用技术。对任何要使用的技术，多问一些挑剔的问题，并真实地做出回答。

**建议**

- 每一门技术都会有优点和缺点，一定要清楚它的利弊。
- 不用开发那些你容易下载到的东西。
- 在考虑引入新技术或框架之前，先要把你需要解决的问题找出来。
- 找到需要解决的问题：你应该这样说：“。。。太难了”或者“。。。花的时间太长了“，或者类似的句子。
- 回答以下几个问题：
  - 这个技术框架真能解决这个问题吗？（如何评估这个技术？要确保它能解决你的问题，并没有任何的毒副作用。如果需要，先做一个小的原型。）
  - 你将会被它拴住吗？（警惕有些技术是缺乏可取消性）
  - 维护成本是多少？（方案的花费不应该高于要解决的问题，否则就是一次失败的投资。如果你发现自己在做一些花哨的东西，那就醒醒吧！）
  - 对象-关系的映射就是计算机科学的越南战场。

> 习惯13：保持可以发布——保持你的项目时刻可以发布

保证你的系统随时可以编译、运行、测试并立即部署。

**建议**

- 任何时候只要你没有准备好，那就是敌人进攻你的最佳时机。
- 在团队里工作，修改一些东西的时候必须很谨慎。
- 推荐以下简单的工作流程，防止提交破坏系统的代码：
  - 在本地运行测试。
  - 检出最新的代码。
  - 提交代码。
- 持续集成系统就是在后台不停地检出、构建和测试代码的应用。
- 不要让即将进行的一次重大修改可能导致系统的破坏，并在代码提交之前，找出可以避免破坏系统的方法。
- 良好的版本控制系统——做一个分支版本

> 习惯 14：提早集成，频繁集成

代码集成是主要的风险来源。要想规避这个风险，只有提早集成，持续而有规律地进行集成。

**建议**

- 敏捷的一个主要特点就是持续开发，而不是三天打鱼两天晒网似的工作。
- 尽可能早地集成也更容易发现风险，这样的风险及相关的代价就会相当低。
- 使用mock对象来隔离对象之间的依赖关系，这样在集成之前就可以先做测试。
- 独立开发和早期集成之间是具有张力的。你一般需要每天集成几次，最好不要2-3天集成一次。
- 成功的集成就意味着所有的单元测试不停地通过。

> 习惯 15：提早实现自动化部署——一开始就实现自动化部署应用

使用部署系统安装你的应用，在不同的机器上用不同的配置文件测试依赖的问题。质量保证人员要像测试应用一样测试部署。

**建议**

- 你要能用一种可重复和可靠的方式，在目标机器上部署你的应用。
- 质量保证人员应该测试部署过程。
- 一开始就进行全面部署，而不是等到项目的后期，这会有很多好处。
- 项目在开发之前，就应该设置好了所有的安装环境。
- andy说：从第一天起就开始交付。
- 系统的安装或部署应该是简单、可靠及可重复。一切都很自然。

> 习惯16：使用演示获得频繁反馈——清晰可见的开发

在开发的时候，要保持应用可见（而且客户心中也要了解）。每隔一周或者两周，邀请所有的客户，给他们演示最新完成的功能，积极获得他们的反馈。

**建议**

- 你无法冻结需求，正如你无法冻结市场、竞争、知识、进化或者成长一样。
- 如果你期望用户在项目开始之前，就能给你可靠和明确的需求，那就大错特错了，赶快醒醒吧！
- 就算是客户已经告诉你想要的东西了，他们的期望和想法还是在不停地进化。
- 作为人类，不管是什么事情，我们都能越做越好，不过是以缓慢而逐步的方式。
- 软件开发的成功就在于最好你离客户的期望有多近。
- 我们经常看到，给客户演示所完成功能的时间与得到客户需求的时间间隔越长，那么你就会离最初需求越来越远。
- 定期地，每隔一段时间，就与客户会晤，并且演示你已经完成的功能特性。客户会基于自己进化的期望和理解为你导航，你编写的程序也就越来越接近客户的真实需求。
- 维护一份项目术语表，确保你真正地和用户进行沟通。从术语表中为程序结构——类、方法、模型、变量等选择合适的名字，并且要检查和确保这些定义一直符合用户的期望。
- 要有一个跟踪系统记录所有有关反馈（修正、建议、变更要求、功能增强、bug修复等）的日志来跟踪问题。
- 演示是用来让客户提出反馈的，有助于驾驭项目的方向。

> 习惯17：使用短迭代，增量发布

发布带有最小却可用功能块的产品。每个增量开发中，使用1-4周左右迭代周期。

**建议**

- 迭代开发是，你在小且重复的周期里完成各种开发任务：分析、设计、实现、测试和获得反馈。迭代的结束就标记一个里程碑。
- Larman 指出，软件开发不是精细的制造业，而是创新活动。
- 对付大项目，最理想的方法就是小步前进，这也是敏捷方法的核心。大步跳跃大大地增加了风险，小步前进才可以帮助你很好地把握平衡。
- 大部分用户都是希望现在就有一个够用的软件，而不是在一年之后得到一个超级的好软件。
- 询问用户，哪些是使产品可用且不可缺少的核心功能。
- 在每个增量开发周期里，应该使用短的迭代（不应该超过两周）。
- 敏捷项目主要的周期关系，如下：
  - 提交代码：保持每日多次在本地构建
  - 演示活动：短迭代1-4周
  - 增量发布：增量1-6月
- 把握好自己的节奏
- 增量的发布必须是可用的，并且能为用户提供价值。

> 习惯18：固定的价格就意味着背叛承诺——基于真实工作的评估

让团队和客户一起，真正地在当前项目中工作，做具体实际的评估。由客户控制他们要的功能和预算。

**建议**

- 软件真的与建筑有很多相似之处——真正地建筑行业，但不是我们想象中的建筑业。
- 软件项目天生就是变化无常的，不可重复。
- 根据自己的处境，选择不同的战略。你可以试试下面的办法。
  - （1）主动提议先构建系统最初的、小的和有用的部分（用建筑来打个比方，就是先做个车库）。挑选一系列小的功能，这样完成第一次交付应该不多于6-8周。向客户解释，这时候还不是要完成所有的功能，而是要足够一次交付，并能让用户真正使用。
  - （2）第一个迭代结束时客户有两个选择：可以选择一系列新的功能，继续进入下一个迭代；或者可以取消合同，仅需支付第一个迭代的几周费用，他们要么把现在的成果扔掉，要么找其他的团队来完成它。
  - （3）如果他们选择继续前进，那么这时候，应该就能很好地预测下一个迭代工作。在下一个迭代结束的时候，用户仍然有同样的选择机会：要么现在停止，要么继续下一个迭代。
- 让客户总是可以控制项目，可以随时停止项目，不需要缴纳任何的违约金。
- 客户会承担更低的风险。而你所做的就是在进行迭代和增量开发。

### 3.4 敏捷反馈 ###

> 习惯19：守护天使——使用自动化的单元测试

好的单元测试能够为你的代码问题提供及时的警报。如果没有到位的单元测试，不要进行任何设计和代码修改。

**建议**

- 为了应对代码的变化，你需要持续获得代码健康状态的反馈：它是在做你期望的事情吗？最近一次修改有没有无意中破坏了什么功能？
- 你可以选择一个标准的测试框架，来帮助你完成简单的编写和组织测试的工作。
- 清楚自己要测试的内容：
  - 确保测试是可重复的
  - 测试你的边界条件
  - 不要放过任何一个失败的测试
- 结合本地单元测试，运行每个编译，构建机器不断编译和运行单元测试，这样你就拥有了一个守护天使。如果出现了问题，你会立即知道，并且这是最容易修复（也是成本最低）的时候。
- 关于单元测试的诸多好处：
  - 它能及时提供反馈
  - 它让你的代码更加健壮
  - 它是有用的设计工具
  - 它是你自信的后台
  - 它是可信的文档
  - 它是学习工具

> 习惯20：先用它再实现它

将TDD作为设计工具，它会为你带来更简单更有实效的设计。

**建议**

- 如果要让你的产品尽可能地好，自己先要积极地使用它。
- 使用被称为TDD（测试驱动设计）的技术。TDD有机会让你编写代码之前，可以深思熟虑将如何用它。这会迫使你去思考它的可用性和便利性，并让你的设计更加注重实效。
- 编码之前，先写测试。
- 先写测试的好处：
  - 你就会站在代码用户的角度来思考，而不仅仅是一个单纯的实现者。
  - 有助于消除过度复杂的设计，让你可以专注于真正需要完成的工作。
- 设计并不是在开始编码后就结束了。
- 不用把测试优先和提交代码之前的测试等同起来。测试先行可以帮助你改进设计。
- 任何一个设计都可以被改进。
- 单纯的单元测试无法保证好的设计，但它们对设计有帮助，会让设计更加简单。

> 习惯21：不同环境，就有不同问题

使用持续集成工具，在每一种支持的平台和环境中运行单元测试。要积极地寻找问题，而不是等问题来找你。

**建议**

- 每次在修改或者重构代码的时候，在提交代码之前，你会运行测试用例。那么现在你要做的就是在各种支持的平台和环境中运行这些测试用例。
- 情景测试：在不同的操作系统上运行、在一个操作系统的不同版本上运行、在不同版本的虚拟机上运行、在不同的.NET CLR 上运行
- 通过持续集成在多个平台上运行测试，可以大幅节约时间。持续集成工具的功用就是周期性地从源代码控制系统中取得代码，并运行代码。如果有任何测试失败了，它会通知相关的开发者。
- 硬件比开发人员的时间便宜。

> 习惯22：自动验收测试——为核心的业务逻辑创建测试。

让你的客户单独验证这些测试，要让它们像一般的测试一样可以自动运行。

**建议**

- 关键业务逻辑必须要独立进行严格的测试，并且最后需要通过用户的审批。
- FIT，即集成测试框架，它很实用，可以更容易地使用HTML表格定义测试用例，并比较测试结果数据。
- 获取验收数据

> 习惯23：度量真实的进度——度量剩下的工作量

不要用不恰当的度量来欺骗自己或者团队。要评估那些需要完成的代办事项。

**建议**

- 判断工作进度最好是看实际花费的时间而不是估计的时间。
- 我们不应该去计算工作量完成的百分比，而应该测定还剩下多少工作量没有完成。
- 这里诚实非常重要，隐瞒真相毫无意义。
- 即便实际花费的时间比最初估计时间长，但是没有关系，我们希望这能作为下一次的参考。
- 如果你低估了一个任务，评估是2天，它最后花费了6天，那么系数就是3。下次估计乘以系数后的时间，作为你的评估时间。你的评估时间会波动一段时间，有时过低估计、有时过高估计。但随着时间的推移，你的评估会与事实接近，那时你对任务所花费的时间将有更清晰的认识。
- 一直让下一步工作是可见的，最好的做法就是使用待办事项。
- 关注功能，而不是日程表。
- 明确合适的时间单位：粒度不要太细，也不要太粗。

> 习惯 24：倾听用户的声音——每一个抱怨背后都隐藏了一个事实。

找出真相，修复真正的问题。

**建议**

- 对于客户的那些愚蠢抱怨，你既不会生气，也不会轻视。你会查看一下，找出背后真正的问题。
- 没有愚蠢的用户，只有愚蠢、自大的开发人员。
- “它就是这样的。”这不是一个好的答案。
- 如果代码问题解决不了，也许可以考虑通过修改文档或者培训来弥补。
- 你的用户可能会阅读所有的文档，记住其中的所有内容。但也可能不会。
- 你不仅需要和真实用户（不是他们的经理，也不是业务分析师之类的代理人）进行交谈，还需要耐心地倾听。

### 3.5 敏捷编码 ###

开发人员在完成项目任务时，要抵挡来自为节约时间而走“捷径”的诱惑。在开发过程中细心“照看”代码，避免后期面对过多的压力。

> 习惯 25：代码要清晰地表达意图——要编写清晰的而不是讨巧的代码

向代码阅读者明确表明你的意图。可读性差的代码一点都不聪明。

**建议**

- 开发代码时，应该更注重可读性，而不是只图自己方便。
- 从衡量标准上来看，代码清晰程度的优先级应该排在执行效率之前。
- 改动代码时，应该如何进行？
  - 首先，应该理解代码做了什么，它是如何做的；（第一步，往往最难）
  - 接下来，搞清楚将要改变哪些部分；
  - 然后，着手修改并进行测试。
- 明白地告诉阅读程序的人，代码都做了什么，这是让其便于理解的一种方式。
- 不要表现得好像很聪明似的，要遵循PIE 原则：代码要清晰地表达意图。
    > **PIE 原则**：program intently and expressively，即意图清楚而且表达明确地编程。
- 违反PIE 原则，不只是影响代码可读性，还会影响到代码的正确性。


> 习惯 26：用代码沟通——用注释沟通

使用细心选择的、有意义的命名。用注释描述代码意图和约束。注释不能替代优秀的代码。

**建议**

- 建立代码文档无外乎两种方式：利用代码本身；利用注释来沟通代码之外的问题；
- 不要用注释来包裹你的代码；使用细心挑选的名称和清晰的执行路径，代码几乎不用注释；
- 源代码可以被读懂，不是因为其中的注释，而应该是由于它本身优雅而清晰；
  - 变量名运用正确
  - 空格使用得当
  - 逻辑分离清晰
  - 表达式非常简洁
- 使用细心挑选的名称，向阅读者传递大量的意图和信息。良好的命名传递大量正确信息，糟糕的命名传递错误的信息。

> 习惯 27：动态评估取舍——动态评估权衡

考虑性能、便利性、生产力、成本和上市时间。如果性能表现足够了，就将注意力放在其他因素上，不要为了感觉上的性能提升或者设计的优雅，而将设计复杂化。

**建议**



> 习惯 28：增量式编码——在很短的编辑/构建/测试循环中编写代码

这要比花费长时间仅仅做编写代码的工作要好得多。可以创建更加清晰、简单、易于维护的代码。

> 习惯 29：保持简单——开发可以工作的、最简单的解决方案

除非有不可辨驳的原因，否则不要使用模式、原则和高难度技术之类的东西。

> 习惯 30：编写内聚的代码——让类的功能尽量集中，让组件尽量小。

要避免创建很大的类或组件，也不要创建无所不包的大杂烩类。


> 习惯 31：告知，不要询问

不要抢别的对象或是组件的工作。告诉它做什么，然后盯着你自己的职责就好了。


> 习惯32 ：根据契约进行替换——提供替换代码来扩展系统

通过替换遵循接口契约的类，来添加并改进功能特性。要多使用委托而不是继承。

### 3.6 敏捷调试 ###

> 习惯 33：记录问题解决日志——维护一个问题及其解决方案的日志

保留解决方案是修复问题的一部分，以后发生相同或类似问题时，就可以很快找到并使用了。

> 习惯 34：警告就是错误——将警告视为错误

签入带有警告的代码，就跟签入有错误或者没有通过测试的代码一样，都是极差的做法。签入构建工具中的代码不应该产生任何警告信息。

> 习惯 35：对问题各个击破

在解决问题时，要将问题域与其周边隔离开，特别是在大型应用中。

> 习惯 36：报告所有的异常——处理或是向上传播所有的异常

不要将它们压制不管，就算是临时这样做也不行，在写代码时要估计到会发生的问题。

> 习惯 37：提供有用的错误信息——展示有用的错误信息

提供更易于查找错误细节的方式。发生问题时，要展示出尽量多的支持细节，不过别让用户陷入其中。

### 3.7 敏捷协作 ###

> 习惯 38：定期安排会面时间——使用立会

立会可以让团队达成共识。保证会议短小精悍不跑题。

> 习惯 39：架构师必须写代码——优秀的设计从积极的程序员那里开始演化

积极的编程可以带来深入理解。不要使用不愿意编程的架构师——不知道系统的真实情况，是无法展开设计的。

> 习惯 40：实行代码集体所有制——要强调代码的集体所有制

让开发人员轮换完成系统不同领域中不同模块的不同任务。

> 习惯 41：成为指导者

分享自己的知识很有趣——付出的同时便有收获。还可以激励别人获得更好的成果，而且提升了整个团队的实力。

> 习惯 42：允许大家自己想办法——给别人解决问题的机会

指给他们正确的方向，而不是直接提供解决方案。每个人都能从中学到不少东西。

> 习惯 43：准备好后再共享代码

绝不要提交尚未完成的代码。故意签入编译未通过或是没有通过单元测试的代码，对项目来说，应被视作玩忽职守的犯罪行为。

> 习惯 44：做代码复查——复查所有的代码

对于提升代码质量和降低错误率来说，代码复查是无价之宝。如果以正确的方式进行，复查可以产生非常实用而高效的成果。要让不同的开发人员在每个任务完成后复查代码。

> 习惯 45：及时通报进展与问题

发布进展状况、新的想法和目前正在关注的主题。不要等着别人来问项目状态如何。



补充：

- Ruby 的创建者是松本行弘



CHANGELOG:

- 2017/2/16 17:29:46 
- 2017/2/17 16:29:27 
- 2017/2/28 15:33:24 
- 2017/3/1 13:23:36 
- 2017/3/2 11:58:57 
- 2017/3/3 22:46:46 
- 2017/3/4 23:58:57 
- 2017/3/6 21:39:22 
- 2017/3/7 9:56:25 